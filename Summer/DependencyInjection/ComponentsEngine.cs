using System.Reflection;
using Summer.DependencyInjection.Attributes;
using Summer.DependencyInjection.Interfaces;

namespace Summer.DependencyInjection;

public static class ComponentsEngine
{
    private static readonly ComponentStore ComponentStore = new();
    public static Assembly ExecutingAssembly { get; set; } = Assembly.GetExecutingAssembly();

    /// <summary>
    /// Discover and initialize Components.
    /// </summary>
    public static void Start()
    {
        Console.WriteLine($"Starting ComponentsEngine.");
        
        var componentTypes = Discover();
        if (componentTypes.Count == 0) return;
        
        InjectDependencies(componentTypes);
        Initialize(componentTypes);
    }

    public static T? GetComponent<T>() where T : class, IComponent
    {
        var component = ComponentStore.Find(typeof(T));
        return component as T;
    }

    public static object? GetComponent(Type type)
    {
        return ComponentStore.Find(type);
    }

    private static List<Type> Discover()
    {
        Console.WriteLine($"Discovering Components...");

        var componentTypes = ExecutingAssembly.GetTypes()
            .Where(t => t.GetInterfaces().Contains(typeof(IComponent))
                        && !t.IsAbstract
                        && !Attribute.IsDefined(t, typeof(IgnoreComponent))
            ).ToList();

        foreach (var componentType in componentTypes)
        {
            ComponentStore.Register(componentType);
            Console.WriteLine($"Registered Component of type {componentType.Name}");
        }

        return componentTypes;
    }

    private static void InjectDependencies(List<Type> componentTypes)
    {
        Console.WriteLine($"Injecting Components...");
        foreach (var componentType in componentTypes)
        {
            // I could've just returned components from the Discover methods and iterate them here to avoid having to call find, 
            // but honestly, dictionary access is O(1) and that way I don't have to worry about returning an object of specific types
            // every time I call ComponentStore.Register(type)
            var componentInstance = ComponentStore.Find(componentType);
            if (componentInstance is null) continue;

            var componentProperties =
                componentType.GetProperties(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public)
                    .Where(property => Attribute.IsDefined(property, typeof(Inject)));

            InjectIntoProperties(componentInstance, componentType, componentProperties);

            var componentFields =
                componentType.GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public)
                    .Where(property => Attribute.IsDefined(property, typeof(Inject)));

            InjectIntoFields(componentInstance, componentType, componentFields);
        }
    }

    private static void InjectIntoProperties(object? componentInstance, Type componentType,
        IEnumerable<PropertyInfo> componentProperties)
    {
        foreach (var property in componentProperties)
        {
            var propertyType = property.PropertyType;
            var componentToBeInjected = ComponentStore.Find(propertyType);

            if (componentToBeInjected == null)
            {
                // Could just register it again, but it should have created it during Discover(), so it shouldn't happen. 
                Console.WriteLine(
                    $"Could not find a component to inject into {componentType.Name}.{propertyType.Name}.");
                continue;
            }

            if (!property.CanWrite)
            {
                // In the future I could just change the backing field generated by C#, but let's keep it simple for now.
                Console.WriteLine($"Property {componentType.Name}.{propertyType.Name} does not have a 'set' accessor.");
                continue;
            }

            property.SetValue(componentInstance, componentToBeInjected);
            Console.WriteLine($"Injected component {propertyType.Name} into {componentType.Name}.");
        }
    }

    private static void InjectIntoFields(object? componentInstance, Type componentType,
        IEnumerable<FieldInfo> componentFields)
    {
        foreach (var field in componentFields)
        {
            var fieldType = field.FieldType;
            var componentToBeInjected = ComponentStore.Find(fieldType);

            if (componentToBeInjected == null)
            {
                // Could just register it again, but it should have created it during Discover(), so it shouldn't happen. 
                Console.WriteLine($"Could not find a component to inject into {componentType.Name}.{fieldType.Name}.");
                continue;
            }

            field.SetValue(componentInstance, componentToBeInjected);
            Console.WriteLine($"Injected component {fieldType.Name} into {componentType.Name}.");
        }
    }

    private static void Initialize(List<Type> componentTypes)
    {
        foreach (var componentType in componentTypes)
        {
            if (ComponentStore.Find(componentType) is not IComponent component)
            {
                Console.WriteLine($"Couldn't find component of type {componentType}.");
                continue;
            }

            component.Initialize();
        }
    }
}